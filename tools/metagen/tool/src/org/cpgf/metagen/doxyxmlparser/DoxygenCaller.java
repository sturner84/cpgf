package org.cpgf.metagen.doxyxmlparser;

import java.io.*;
import java.net.*;
import java.util.*;
import java.util.regex.*;

import org.cpgf.metagen.*;
import org.cpgf.metagen.filters.*;

//TODO WARNING - May not work in XP (or earlier) if source code is not in the 
//current working directory.  Doxygen messes with the paths and switches 
// \ to /.  Eariler version of Windows do not like it.  Windows 7 seems to be
// okay with it.


// -------------------------------------------------------------------------
/**
 *  Finds the doxygen executable and uses it to generate xml files for the 
 *  code.
 *
 *  @author  scturner
 *  @version Jan 20, 2014
 */
public class DoxygenCaller
{
    private Config config;
    private boolean wasError;
    private String errorMsg;
    private boolean wasWarning;
    private String warningMsg;
    private String outputMsg;
    private List<String> srcFiles; 
    private boolean showExtendedInfo;
    
    /**
     * Creates the object with the specified configuration
     * @param configuration metagen configuration to use
     */
    public DoxygenCaller(Config configuration)
    {
        config = configuration;        
        srcFiles = null;
        showExtendedInfo = false;
    }
    
    /**
     * Creates the object with the specified configuration
     * @param configuration metagen configuration to use
     * @param extInfo Determines if extended information is generated
     */
    public DoxygenCaller(Config configuration, boolean extInfo)
    {
        config = configuration;        
        srcFiles = null;
        showExtendedInfo = extInfo;
    }
    
    public boolean isExtendedInfoOn() {
        return showExtendedInfo;
    }
    
    public void setExtendedInfo(boolean extInfo) {
        showExtendedInfo = extInfo;
    }

    /**
     * Determines if an error occurred with trying to call Doxygen
     * @return true if an error occurred
     */
    public boolean hasError() {
        return wasError;        
    }
    
    /**
     * Gets the error message generated
     * @return Error message or "" if no error occurred.
     */
    public String getError() {
        return errorMsg;
    }
    
    /**
     * Determines if a warning occurred with trying to call Doxygen
     * @return true if a warning occurred
     */
    public boolean hasWarning() {
        return wasWarning;        
    }
    
    /**
     * Gets the warning message generated
     * @return Warning message or "" if no warning occurred.
     */
    public String getWarning() {
        return warningMsg;
    }
    
    /**
     * Gets the output generated by doxygen
     * @return Output, if any, that doxygen generates
     */
    public String getOutput() {
        return outputMsg;
    }
    
    /**
     * Runs doxygen and returns the location of the output's index file. If
     * an error occurs, the index file is null.
     * 
     * @return The index file or null if an error occurred.
     */
    public File run(List<String> sourceFiles) {
        wasError = false;
        errorMsg = "";
        wasWarning = false;
        warningMsg = "";
        outputMsg = "";
        srcFiles = sourceFiles;
                
        File doxygenOutputFile = new File(config.doxygenOutput);
        if (!doxygenOutputFile.exists() && !doxygenOutputFile.mkdirs()) {
            wasError = true;
            errorMsg = "When using --autoxml, the doxygenOutput " +
               "configuration option must be set to a valid, accessable" +
               " directory";           
        }
        
        call(); //run doxygen
        
        //check if index.xml exists        
        File indexFile = new File(doxygenOutputFile.getPath() + "/index.xml");
        
        if (showExtendedInfo) {
            outputMsg += "Index file: " + indexFile.getPath() + "\n";
        }
        if (!wasError && !indexFile.exists()) {
            wasError = true;
            errorMsg = "--autoxml was used but doxygen's index.xml " +
            		"file could not be created.";            
        }
        
        if (!wasError) {
            return indexFile;
        }
        
        return null;
    }
    
    private void call() {
        File doxygen = getDoxygen();
        File configFile = getDoxygenConfigFile();

        //call doxygen with set of options
     
        if (wasError)
            return;
        
        if (showExtendedInfo) {
            outputMsg += "Doxygen path: " + doxygen.getPath() + "\n";
            outputMsg += "Config file path: " + configFile.getPath() + "\n";
        }
        
        if (!wasError) {
            try
            {
                String outFolder = getXMLOutputFolder();
                deleteOutputFolder(new File(outFolder));
                
                Process doxygenProc = Runtime.getRuntime().exec(
                    "\"" + doxygen.getPath() + "\" \"" 
                                    + configFile.getPath() + "\"");

                //readers to get any output
                ProcessStreamReader error = new ProcessStreamReader(
                    doxygenProc.getErrorStream());
                ProcessStreamReader output = new ProcessStreamReader(
                    doxygenProc.getInputStream());

                error.start();
                output.start();

                int exitcode = doxygenProc.waitFor();
                error.join(); //wait for threads to finish
                output.join();

                outputMsg += output.getMessage();
                if (exitcode != 0) {
                    wasWarning = true;
                    warningMsg += "doxygen exited with a code of " + exitcode;
                    warningMsg += "\nError:\n";
                    warningMsg += error.getMessage();
                }
            }
            catch ( IOException e )
            {
                wasError = true;
                errorMsg = "An error occurred with trying to run doxygen. " +
                                "The XML may not have been generated.";
            }
            catch ( InterruptedException e )
            {
                wasError = true;
                errorMsg = "An error occurred with trying to run doxygen. " +
                                "The XML may not have been generated.";
            }
        }
//      delete temp config file 
        configFile.delete();        
    }
    
    private File getDoxygen() {
        //quit if there was already an error
        if (wasError) {
            return null;
        }
        
        File doxygen = null;
//      check for doxygen
        if (config.doxygenFile != null && !config.doxygenFile.isEmpty()) {
            doxygen = new File(config.doxygenFile);
            if (!doxygen.exists()) {
                //print error but try to use the default one
                wasWarning = true;
                warningMsg += "Doxygen could not be found at: \"" 
                + config.doxygenFile + "\". Chech your path. " +
                        "Trying default installation of doxygen...\n";
                doxygen = null;
            }
        }
        
        OsCheck.OSType osType = OsCheck.getOperatingSystemType();
        //String osTypeStr = "Unknown (guessing linux)";
        String fileName = "doxygen";
        String subDir = "";
//      determine OS
        switch (osType) {
            case Windows:
                fileName = "doxygen.exe";
                //osTypeStr = "Windows";
                subDir = "win";
                break;
            case MacOS:
                //osTypeStr = "Mac OS";
                subDir = "mac";
                break;
            case Linux:
                //osTypeStr = "Linux";
                subDir = "linux";
                break;
            case Other:
                //do nothing
                subDir = "linux";
                break;
        }

//      check if appropriate executable is found
//      try doxygen folder first and then specific folders underneath it
        if (doxygen == null) {
            //System.out.println(getDefaultDoxygenDirectory() + fileName);
            //doxygen = new File("./doxygen/" + fileName);
            doxygen = new File(getDefaultDoxygenDirectory() + fileName);
            if (!doxygen.exists()) {
                //try the specific subfolder
                ///System.out.println(getDefaultDoxygenDirectory() + subDir + "/" + fileName);
                //doxygen = new File("./doxygen/" + subDir + "/" + fileName);
                doxygen = new File(getDefaultDoxygenDirectory() + subDir + "/" + fileName);
                if (!doxygen.exists()) {
                    doxygen = null;
                }
            }
        }
        
        //couldn't find it at all
        if (doxygen == null) {
            wasError = true;
            errorMsg += "A version of doxygen appropriate for the " 
                + osType.toString() 
                + " OS could not be found in the metagen's " +
                    "doxygen directory. Please check your setup. The " +
                    "doxygen file in those directories should called " +
                    "doxygen[.exe] (as appropriate for the OS)." ;
        }
        
        return doxygen;
    }
    
    private File getDoxygenConfigFile() {
      //quit if there was already an error
        if (wasError) {
            return null;
        }
        
        File configFile = null;
        
        // config option for path to doxygen
//      use default if not there or invalid
//          error message stating default used
        if (config.doxygenConfigFile != null 
               && !config.doxygenConfigFile.isEmpty()) {
            configFile = new File(config.doxygenConfigFile);
            if (!configFile.exists()) {
                //print error but try to use the default one
                wasWarning = true;
                warningMsg += "Doxygen's configuration file" +
                        " could not be found at: \"" 
                + config.doxygenConfigFile + "\". Chech your path. " +
                        "Trying default configuration file for doxygen...\n";
                configFile = null;
            }
        }
        
        if (configFile == null) {
            //System.out.println(getDefaultDoxygenDirectory() + "defaultconfig.doxyfile");
            configFile = new File(getDefaultDoxygenDirectory() + "defaultconfig.doxyfile");
            //configFile = new File("./doxygen/defaultconfig.doxyfile");
            if (!configFile.exists()) {
                configFile = null;                
            }
        }
        
        if (configFile == null) {
            wasError = true;
            errorMsg = "A configuration file for doxygen could not be found.  "
                    + "A default configuration should be in metagen's doxygen "
                    + "folder but it could not be found. Check " +
                    "your installation.";
        }
        
        return rewriteDoxygenConfigFile(configFile);
    }
    
    private List<String> getInputList(boolean recurse) {
      //quit if there was already an error
        if (wasError) {
            return null;
        }
        
        //if no source files, add the current directory
        if (srcFiles == null || srcFiles.size() == 0) {
            if (srcFiles == null) {
                srcFiles = new LinkedList<String>();
            }
            srcFiles.add("./");
        }
        
        //recurse if the doxygen config file says to
        Set<String> allFiles = getAllInputFiles(srcFiles, recurse);
        
        LinkedList<String> inputFiles = new LinkedList<String>();
        
        //filter everything
        boolean exSrc = config.excludeSource;
        boolean createHdr = config.createHeaderFiles;
        String exReg = config.excludeRegEx;
        String fakeReg = "";
        
        if (config.excludeRegEx == null) {
            exReg = "";
        }
        
        if (showExtendedInfo) {
            outputMsg += "Excluding Source Files: " + exSrc + "\n";
            outputMsg += "Creating Header Files: " + createHdr + "\n";
            outputMsg += "Exclude pattern: " + exReg + "\n";
        }
        //TODO fix if so that exScr or exReg
        // |(.*/" 
        //+ createHeaderFilesPrefix + "[^/]*)
        //add filter for fake headers here
        //stop fake_runAllTests from happening?
        String exSrcStr = "";
        Set<String> srcToKeep;
        if (exSrc) {
            exSrcStr = "(.*(?:" + Config.SRC_EXTENSIONS + "))";
        }

        //get set of source files to keep
        if (createHdr) { //if we need to keep some source files around
            UnmatchedSourceFilter sourceFilter = new UnmatchedSourceFilter(allFiles,
                config);
            srcToKeep = sourceFilter.getUnmatchedSourceFiles();
            fakeReg = "(.*/" + config.createHeaderFilesPrefix + "[^/]*)";
        }
        else {
            srcToKeep = new HashSet<String>();
        }

        Pattern exRegex = Pattern.compile("((" + exReg + ")|(" + fakeReg + "))");
        Pattern exSource = Pattern.compile(exSrcStr);
        String action;

        if (showExtendedInfo) {
            outputMsg += "Processing Files:\n"; 
        }
        for (String file : allFiles) {
            action = "Included";
            file = file.replaceAll("\\\\", "/");   
            //check against the source files first
            //and against exclude regex
            if ((exSource.matcher(file).matches() 
                            && !srcToKeep.contains(file)) 
                            || exRegex.matcher(file).matches()) {
                action = "Excluded";
            }
            else {

                inputFiles.add(file); //keep                  
            }
            if (showExtendedInfo) {
                outputMsg += "\t" + action + ": " + file + "\n"; 
            }
        }

        return inputFiles;
    }
    
    private Set<String> getAllInputFiles(List<String> sourceFiles, 
        boolean recurse) {
      //quit if there was already an error
        if (wasError) {
            return null;
        }
        
        HashSet<String> allFiles = new HashSet<String>();
        for (String file : sourceFiles) {
            allFiles.addAll(getFiles(new File(file), recurse));
        }
        
        return allFiles;
    }
    
    Set<String> getFiles(File file, boolean recurse) {
        //queue for breadth first search if recursing
        HashSet<String> files = new HashSet<String>(); 
        LinkedList<File> directories = new LinkedList<File>();
        File currFile;
                
        //filter out non-source/header files
        Pattern cPattern = Pattern.compile(".*(?:" + Config.SRC_EXTENSIONS + "|" 
            + Config.HDR_EXTENSIONS + ")");
                        
        
        //check if file or directory exists
        if (file != null && file.exists()) {
            if (file.isDirectory()) {
                //add to queue
                directories.addLast(file);
                //while things are queued
                while (directories.size() > 0) {
                    currFile = directories.removeFirst();
                    //go through all the files in the directory
                    for (File f : currFile.listFiles()) {
                        //if recursing and it is a directory, add it to list of
                        //directories
                        if (recurse && f.isDirectory() 
                             && !f.getName().equals(".") 
                             && !f.getName().equals("..")) {
                            directories.addLast(f);
                        }
                        //if file, add to list of files
                        if (f.isFile()) {
                            //determine if it is a source or header file
                            if (cPattern.matcher(f.getName()).matches()) {
                                files.add(f.getPath());
                            }
                        }
                    }   
                }
            }
            else {
                if (file.isFile()) {
                    //if this is a file, they put it there specifically, so 
                    //we are not filtering it
                    files.add(file.getPath());
                }
            }
        }
        
        return files;
    }
    
    private boolean isRecurseSet(File doxygenConfigFile) {
      //quit if there was already an error
        if (wasError) {
            return false;
        }
        
        boolean recurse = false;
        final String DOXYGEN_ATTRIBUTE_REGEX 
            = "(?i)(?:(?:^|[\\r\\n])\\s*)%s[^\\\\\\r\\n]*" +
                    "(?:(?:\\\\\\s*[\\r\\n][^\\\\\\r\\n]*)*[\\r\\n])";
        final String DOXYGEN_VALUE_REGEX = "(?is).*[=\\s]%s\\s.*";             
        
        if (doxygenConfigFile.exists()) {
            FileContentFilter fFilter = new FileContentFilter(
                doxygenConfigFile.getPath());
            try
            {
                List<String> recAttribute = fFilter.find(
                    String.format(DOXYGEN_ATTRIBUTE_REGEX, "recursive"));
                //use only the last one
                if (recAttribute.size() > 0) {
                    String value = recAttribute.get(recAttribute.size() - 1);
                    recurse = value.matches(String.format(DOXYGEN_VALUE_REGEX,
                        "yes"));
                }
            }
            catch ( IOException e )
            {
                // do nothing, recurse stays false
            }
        }
        
        return recurse;
    }
    
    private String getExcludePatterns() {
      //quit if there was already an error
        if (wasError) {
            return null;
        }
        
        String excludeStr = "";
        
        if (config.excludeRegEx != null) {
            excludeStr += config.excludeRegEx + " ";
        }
        
//        if (config.createHeaderFiles) {
//            excludeStr += "*/" + config.createHeaderFilesPrefix + "* ";
//        }
        
        return excludeStr;
    }
    
    private String getXMLOutputFolder() {
      //quit if there was already an error
        if (wasError) {
            return null;
        }
        
        File outFolder = null;
        
        //check the config first
        if (config.doxygenOutput != null && !config.doxygenOutput.isEmpty()) {
            outFolder = new File(config.doxygenOutput);
            //fail if it cannot be created
            if (!outFolder.exists() && !outFolder.mkdirs()) {
                outFolder = null;
            }
        }
        
        //check default if needed         
        if (outFolder == null) {
            outFolder = new File(Config.DEFAULT_DOXYGEN_OUTPUT);
            //fail if it cannot be created
            if (!outFolder.exists() && !outFolder.mkdirs()) {
                wasError = true;
                errorMsg = "The xml output folder could not be created.";
            }
        }
        
       return outFolder.getPath(); 
    }
    
    private File rewriteDoxygenConfigFile(File configFile) {
      //quit if there was already an error
        if (wasError) {
            return null;
        }
                
        boolean recurse = isRecurseSet(configFile);
        String output = getXMLOutputFolder();
        List<String> inputs = getInputList(recurse);
        String excludes = getExcludePatterns();
        
        if (showExtendedInfo) {
            outputMsg += "Output Directory: " + output + "\n"; 
            outputMsg += "Additional exclude pattern: " + excludes + "\n"; 
        }
        
        String tmpName = "./" + configFile.getName() 
           + Config.TEMP_CONFIG_FILE_POSTFIX;
        File tmpFile = null;
        
        try
        {
            tmpFile = new File(tmpName);
            PrintWriter out
                = new PrintWriter(new BufferedWriter(new FileWriter(tmpFile)));
            if (configFile.exists()) {
               Scanner scan = new Scanner(configFile); 
               while (scan.hasNextLine()) {
                   out.println(scan.nextLine());
               }
               scan.close();
            }
            
            out.println();
            out.println();            
            out.println("# Values added by metagen.");
            out.println("INPUT += " + listToString(inputs));
            //out.println("INPUT += " + "Z:\\cppWorkspace\\LookingGlassTestData\\mainTesting.cpp");
            
            //out.println("EXCLUDE_PATTERNS += " + excludes);
            out.println("XML_OUTPUT = \"" + output + "\"");
            out.close();
        }
        catch ( IOException e )
        {
            wasError = true;
            errorMsg = "The temporary config file could not be " +
                    "written to.";
            tmpFile = null;
        }

        return tmpFile;
    }
    
    private String listToString(List<String> list) {
        String values = "";
        
        if (list != null) {         
            for (String s : list) {
                values += "\"" + s + "\" ";
            }           
        }
        
        return values;
    }
    
    /**
     * This might be a horrible hack to get a relative path to the program that
     * is running.  However, it is not known where the program is and the
     * program will be called from many different places and the resources 
     * should be found for all of those calls.
     *   
     * Adding the resources to the jar is out of the question as they are 
     * programs and will not run in a zip file. 
     */
    private String getDefaultDoxygenDirectory() {
        
        Class<?> currClass = this.getClass();
        
        final String JAR_PREFIX = "jar:";
        final String FILE_PREFIX = "file:/";
        final String CURRENT_PACKAGE = currClass.getPackage().getName()
                        .replaceAll("\\.", "/") ;
        final String JAR_SEPARATOR = "!";
        
        //System.out.println(currClass.getName().replaceAll("\\.", "/") + ".class");
        URL dURL = currClass.getResource(
            currClass.getSimpleName() + ".class");
       // System.out.println(dURL);
        String directory = dURL.toString();
        
        if (directory.startsWith(JAR_PREFIX)) {
            int pos = directory.indexOf(JAR_SEPARATOR);
            int lastSlash;
            if (pos == -1) {
                pos = directory.length();
            }
            
            lastSlash = directory.lastIndexOf("/", pos);  
            if (lastSlash > -1) {
                directory = directory.substring(JAR_PREFIX.length(), 
                    lastSlash + 1); //include last slash
            }
            else {
                directory = directory.substring(JAR_PREFIX.length());
            }
        }
        else {
            //just remove the package
            int pos = directory.indexOf(CURRENT_PACKAGE);
            if (pos > -1) {
                directory = directory.substring(0, pos);
            }
            //move it to the project level
            if (directory.endsWith("bin/") || directory.endsWith("src/")) {
                directory = directory.substring(0, directory.length() - 4);
            }
        }
        
        if (directory.startsWith(FILE_PREFIX)) {
            directory = directory.substring(FILE_PREFIX.length());
        }
        
        //System.out.println(directory);
        
        return directory + "doxygen/";
        
//        return System.getProperty("user.dir")
//                        + System.getProperty("file.separator") + "doxygen"
//                        + System.getProperty("file.separator");
    }
    
    private void deleteOutputFolder(File outputFolder) {
        //queue for breadth first search
        LinkedList<File> directories = new LinkedList<File>();
        int position = 0;
        File currFile;

        directories.addLast(outputFolder);

        if (showExtendedInfo) {
            outputMsg += "Deleting " + outputFolder.getPath() + "\n";
        }
        //while things are queued
        while (position < directories.size()) {
            currFile = directories.get(position);
            position++;
            //go through all the files in the directory
            for (File f : currFile.listFiles()) {
                //if recursing and it is a directory, add it to list of
                //directories
                if (f.isDirectory() 
                                && !f.getName().equals(".") 
                                && !f.getName().equals("..")) {
                    directories.addLast(f);
                }
                //if file, delete it
                String fileName = f.getName();
                if (f.isFile() && (fileName.endsWith(".xml") 
                                || fileName.endsWith(".xslt")
                                || fileName.endsWith(".xsd"))) {
                    //System.out.println("Deleting " + f.getPath());
                    if (showExtendedInfo) {
                        outputMsg += "\tDeleting " + f.getPath() + "\n";
                    }
                    f.delete();
                }
            }   
        }
        
        //don't do last one, it is the output directory
        for (int i = position - 1; i > 0; i--) {
            //System.out.println("Deleting " + directories.get(i).getPath());
            if (showExtendedInfo) {
                outputMsg += "\tDeleting " + directories.get(i).getPath() + "\n";
            }
            directories.get(i).delete();
        }

    }
}
